# 设计文档

## 架构决策

### 1. 为什么自研 RESP 协议而非使用 ioredis/redis

| 维度 | 自研 | 使用现有库 |
|------|------|-----------|
| 学习价值 | ✅ 高 | ❌ 低 |
| 包体积 | ✅ 小 | ❌ 大 |
| 可控性 | ✅ 完全可控 | ⚠️ 受限于库 |
| 开发效率 | ⚠️ 较低 | ✅ 高 |
| 功能完整性 | ⚠️ 需自行实现 | ✅ 开箱即用 |

**取舍说明**：选择自研，牺牲开发效率换取学习价值和可控性。

### 2. 为什么选择 Electron 而非 Tauri

| 维度 | Electron | Tauri |
|------|----------|-------|
| 包体积 | ❌ ~150MB | ✅ ~10MB |
| 内存占用 | ❌ 较高 | ✅ 较低 |
| Node API | ✅ 原生支持 | ❌ 需桥接 |
| 开发效率 | ✅ 高 | ⚠️ 需 Rust |
| 生态成熟度 | ✅ 成熟 | ⚠️ 发展中 |

**取舍说明**：选择 Electron，因为需要 Node.js 的 `net` 模块实现 TCP 通信，且生态更成熟。

### 3. 状态管理方案

当前使用 React useState + props drilling，原因：
- 应用规模较小
- 状态层级不深
- 避免引入额外依赖

**技术债**：如果后续功能复杂化，考虑引入 Zustand 或 Jotai。

## 协议实现细节

### RESP 解析器设计

采用**流式解析**设计，支持 TCP 分包场景：

```
数据到达 → 追加到缓冲区 → 尝试解析 → 
├─ 成功 → 返回结果，移动偏移量
└─ 数据不完整 → 回滚偏移量，等待更多数据
```

关键类：
- `RespParser`: 有状态的流式解析器
- `IncompleteDataError`: 内部异常，标识数据不完整

### 命令序列化

所有命令统一序列化为 RESP 数组格式：

```
SET key value
→ *3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
```

## 安全考虑

1. **密码不持久化**：连接配置保存时不存储密码
2. **Context Isolation**：Electron 启用上下文隔离
3. **CSP**：设置 Content-Security-Policy 头

## 变更历史

| 日期 | 变更 | 原因 |
|------|------|------|
| 2024-01-01 | 初始架构设计 | 项目创建 |
